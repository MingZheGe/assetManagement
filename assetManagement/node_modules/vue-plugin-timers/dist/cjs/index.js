'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vueClassComponent = require('vue-class-component');

class ComponentTimer {
    constructor(methodName, interval = 1000, repeat = false, args) {
        this.repeat = false;
        this.interval = 1000;
        this.timerId = -1;
        this.repeat = repeat;
        this.interval = interval;
        this.methodName = methodName;
        this.state = 'created';
        this.args = args;
    }
    start() {
        if (this.state === 'running' || this.state === 'expired') {
            return;
        }
        if (this.repeat) {
            this.timerId = setInterval(() => {
                this.args ? this.method(...this.args()) : this.method();
            }, this.interval);
            this.state = 'running';
        }
        else {
            this.timerId = setTimeout(() => {
                this.args ? this.method(...this.args()) : this.method();
                this.state = 'expired';
            }, this.interval);
            this.state = 'running';
        }
    }
    stop() {
        if (this.repeat) {
            clearInterval(this.timerId);
        }
        else {
            clearTimeout(this.timerId);
        }
        this.state = 'stopped';
    }
    setVM(vm) {
        this.vm = vm;
        if (!this.vm[this.methodName]) {
            throw new Error('ERR_METHOD_NOT_FOUND: Method name in timer is probably wrong');
        }
        this.method = this.vm[this.methodName].bind(this.vm);
        if (this.args) {
            this.args = this.args.bind(this.vm);
        }
    }
}

var VueTimersMixin = {
    data() {
        if (!this.$options.timers) {
            return {};
        }
        else {
            return {
                timers: Object.keys(this.$options.timers).map((key) => new ComponentTimer(key, this.$options.timers[key].interval, this.$options.timers[key].repeat, this.$options.timers[key].args))
            };
        }
    },
    created() {
        if (!this.timers)
            return;
        let vm = this;
        let timers = this.timers;
        timers.forEach((timer) => timer.setVM(vm));
        // @ts-ignore
        vm.$timers = {
            start: () => {
                timers.forEach((timer) => {
                    console.log(`start: ${timer.methodName} ${timer.state}`);
                    timer.start();
                });
            },
            stop: () => {
                timers.forEach((timer) => {
                    console.log(`stop: ${timer.methodName} ${timer.state}`);
                    timer.stop();
                });
            }
        };
    },
    mounted() {
        if (!this.timers) {
            return;
        }
        this.$timers.start();
    },
    beforeDestroy() {
        if (!this.timers) {
            return;
        }
        this.$timers.stop();
    }
};

function timerDecorator(opt) {
    return vueClassComponent.createDecorator((options, key) => {
        if (!options.timers) {
            options.timers = {};
        }
        options.timers[key] = {
            interval: opt.interval || 1000,
            repeat: opt.repeat || false,
            args: opt.args
        };
    });
}
// @ts-ignore
{
    exports.Timer = timerDecorator;
}

function index (Vue) {
    Vue.mixin(VueTimersMixin);
}

exports.VueTimersMixin = VueTimersMixin;
exports.default = index;
//# sourceMappingURL=index.js.map
