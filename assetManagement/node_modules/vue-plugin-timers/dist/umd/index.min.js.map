{"version":3,"file":"index.min.js","sources":["../../src/ComponentTimer.ts","../../src/mixin.ts","../../src/index.ts"],"sourcesContent":["import { Vue } from 'vue/types/vue'\n\nexport type TimerState = 'created' | 'running' | 'expired' | 'stopped'\nexport default class ComponentTimer {\n  repeat = false\n  interval = 1000\n  timerId: NodeJS.Timer | number = -1\n  vm!: Vue\n  methodName: string\n  state: TimerState\n  method!: Function\n  args?: () => []\n\n  start() {\n    if (this.state === 'running' || this.state === 'expired') {\n      return\n    }\n    if (this.repeat) {\n      this.timerId = setInterval(() => {\n        this.args ? this.method(...this.args()) : this.method()\n      }, this.interval)\n      this.state = 'running'\n    } else {\n      this.timerId = setTimeout(() => {\n        this.args ? this.method(...this.args()) : this.method()\n        this.state = 'expired'\n      }, this.interval)\n      this.state = 'running'\n    }\n  }\n  stop() {\n    if (this.repeat) {\n      clearInterval(this.timerId as number)\n    } else {\n      clearTimeout(this.timerId as number)\n    }\n    this.state = 'stopped'\n  }\n\n  constructor(\n    methodName: string,\n    interval: number = 1000,\n    repeat: boolean = false,\n    args?: <V extends Vue>(this: V) => []\n  ) {\n    this.repeat = repeat\n    this.interval = interval\n    this.methodName = methodName\n    this.state = 'created'\n    this.args = args\n  }\n  setVM(vm: Vue) {\n    this.vm = vm\n    if (!(this.vm as any)[this.methodName]) {\n      throw new Error('ERR_METHOD_NOT_FOUND: Method name in timer is probably wrong')\n    }\n    this.method = ((this.vm as any)[this.methodName] as Function).bind(this.vm)\n    if (this.args) {\n      this.args = this.args.bind(this.vm)\n    }\n  }\n}\n","import { ComponentOptions } from 'vue'\nimport { Vue, VueConstructor } from 'vue/types/vue'\nimport ComponentTimer from './ComponentTimer'\nimport { VueClass } from 'vue-class-component/lib/declarations'\n\nexport default {\n  data() {\n    if (!this.$options.timers) {\n      return {}\n    } else {\n      return {\n        timers: Object.keys(this.$options.timers).map(\n          (key) =>\n            new ComponentTimer(\n              key,\n              this.$options.timers![key].interval,\n              this.$options.timers![key].repeat,\n              this.$options.timers![key].args\n            )\n        )\n      }\n    }\n  },\n  created() {\n    if (!this.timers) return\n    let vm = this as Vue\n    let timers = this.timers\n    timers.forEach((timer) => timer.setVM(vm))\n    // @ts-ignore\n    vm.$timers = {\n      start: () => {\n        timers.forEach((timer) => {\n          console.log(`start: ${timer.methodName} ${timer.state}`)\n          timer.start()\n        })\n      },\n      stop: () => {\n        timers.forEach((timer) => {\n          console.log(`stop: ${timer.methodName} ${timer.state}`)\n          timer.stop()\n        })\n      }\n    }\n  },\n  mounted() {\n    if (!this.timers) {\n      return\n    }\n    this.$timers.start()\n  },\n  beforeDestroy() {\n    if (!this.timers) {\n      return\n    }\n    this.$timers.stop()\n  }\n} as typeof Vue & Vue & ComponentOptions<Vue> & { timers: ComponentTimer[] }\n","import VC, { Vue } from 'vue/types/vue'\nimport VueTimersMixin from './mixin'\n\nexport { VueTimersMixin }\nexport { Timer } from './decorator'\n\nexport default function(Vue: VC.VueConstructor) {\n  Vue.mixin(VueTimersMixin)\n}\n\ntype DefaultTimers<V, Methods> = {\n  [key in keyof Methods]: {\n    repeat?: boolean\n    interval?: number\n    args?: (this: V) => []\n  }\n}\ndeclare module 'vue/types/options' {\n  export interface ComponentOptions<\n    V extends Vue,\n    Data = DefaultData<V>,\n    Methods = DefaultMethods<V>,\n    Computed = DefaultComputed,\n    PropsDef = PropsDefinition<DefaultProps>,\n    Props = DefaultProps\n  > {\n    timers?: DefaultTimers<V, Methods>\n  }\n}\ndeclare module 'vue/types/vue' {\n  export interface Vue {\n    readonly $timers: { start: Function; stop: Function }\n  }\n}\n"],"names":["methodName","interval","repeat","args","this","state","ComponentTimer","timerId","setInterval","_this","method","setTimeout","clearInterval","clearTimeout","vm","Error","bind","data","$options","timers","Object","keys","map","key","created","forEach","timer","setVM","$timers","start","console","log","stop","mounted","beforeDestroy","Vue","mixin","VueTimersMixin"],"mappings":"4QAGA,iBAoCE,WACEA,EACAC,EACAC,EACAC,gBAFAF,oBACAC,MAtCFE,aAAS,EACTA,cAAW,IACXA,cAAkC,EAuChCA,KAAKF,OAASA,EACdE,KAAKH,SAAWA,EAChBG,KAAKJ,WAAaA,EAClBI,KAAKC,MAAQ,UACbD,KAAKD,KAAOA,EAYhB,OAhDEG,kBAAA,WAAA,WACqB,YAAfF,KAAKC,OAAsC,YAAfD,KAAKC,QAGjCD,KAAKF,OACPE,KAAKG,QAAUC,YAAY,WACzBC,EAAKN,KAAOM,EAAKC,aAALD,EAAeA,EAAKN,QAAUM,EAAKC,UAC9CN,KAAKH,UAGRG,KAAKG,QAAUI,WAAW,WACxBF,EAAKN,KAAOM,EAAKC,aAALD,EAAeA,EAAKN,QAAUM,EAAKC,SAC/CD,EAAKJ,MAAQ,WACZD,KAAKH,UALRG,KAAKC,MAAQ,YASjBC,iBAAA,WACMF,KAAKF,OACPU,cAAcR,KAAKG,SAEnBM,aAAaT,KAAKG,SAEpBH,KAAKC,MAAQ,WAefC,kBAAA,SAAMQ,GAEJ,GADAV,KAAKU,GAAKA,GACJV,KAAKU,GAAWV,KAAKJ,YACzB,MAAM,IAAIe,MAAM,gEAElBX,KAAKM,OAAWN,KAAKU,GAAWV,KAAKJ,YAAyBgB,KAAKZ,KAAKU,IACpEV,KAAKD,OACPC,KAAKD,KAAOC,KAAKD,KAAKa,KAAKZ,KAAKU,aCrDvB,CACbG,gBAAA,WACE,OAAKb,KAAKc,SAASC,OAGV,CACLA,OAAQC,OAAOC,KAAKjB,KAAKc,SAASC,QAAQG,IACxC,SAACC,GACC,OAAA,IAAIjB,EACFiB,EACAd,EAAKS,SAASC,OAAQI,GAAKtB,SAC3BQ,EAAKS,SAASC,OAAQI,GAAKrB,OAC3BO,EAAKS,SAASC,OAAQI,GAAKpB,SAT5B,IAeXqB,mBACE,GAAKpB,KAAKe,OAAV,CACA,IAAIL,EAAKV,KACLe,EAASf,KAAKe,OAClBA,EAAOM,QAAQ,SAACC,GAAU,OAAAA,EAAMC,MAAMb,KAEtCA,EAAGc,QAAU,CACXC,MAAO,WACLV,EAAOM,QAAQ,SAACC,GACdI,QAAQC,IAAI,UAAUL,EAAM1B,eAAc0B,EAAMrB,OAChDqB,EAAMG,WAGVG,KAAM,WACJb,EAAOM,QAAQ,SAACC,GACdI,QAAQC,IAAI,SAASL,EAAM1B,eAAc0B,EAAMrB,OAC/CqB,EAAMM,aAKdC,mBACO7B,KAAKe,QAGVf,KAAKwB,QAAQC,SAEfK,yBACO9B,KAAKe,QAGVf,KAAKwB,QAAQI,+CChDOG,GACtBA,EAAIC,MAAMC"}